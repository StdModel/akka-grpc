@*
 * Copyright (C) 2018 Lightbend Inc. <https://www.lightbend.com>
 *@

@(service: akka.grpc.gen.javadsl.Service, powerApis: Boolean)

@akka.grpc.gen.Constants.DoNotEditComment
package @service.packageName

import akka.actor.ActorSystem;
import akka.grpc.GrpcServiceException;
import akka.grpc.internal.PlayRouterUsingActions;
import akka.grpc.javadsl.GrpcExceptionHandler;
import akka.http.scaladsl.model.ContentType;
import akka.http.scaladsl.model.HttpHeader;
import akka.http.scaladsl.model.HttpMethod;
import akka.http.scaladsl.model.HttpProtocol;
import akka.http.scaladsl.model.HttpRequest;
import akka.http.scaladsl.model.HttpResponse;
import akka.http.scaladsl.model.ResponseEntity;
import akka.http.scaladsl.model.HttpEntity.Chunk;
import akka.http.scaladsl.model.HttpEntity.Chunked;
import akka.http.scaladsl.model.HttpEntity.LastChunk;
import akka.http.scaladsl.model.HttpHeader.ParsingResult;
import akka.http.scaladsl.model.HttpHeader.ParsingResult.Error;
import akka.http.scaladsl.model.HttpHeader.ParsingResult.Ok;

import akka.http.javadsl.model.Uri;
import akka.stream.Materializer;
import akka.stream.scaladsl.Source;
import akka.util.ByteString;
import java.lang.invoke.SerializedLambda;
import javax.inject.Inject;
import play.api.http.ContentTypes;
import play.api.http.FileMimeTypes;
import play.api.http.HeaderNames;
import play.api.http.HttpChunk;
import play.api.i18n.Langs;
import play.api.i18n.MessagesApi;
import play.api.mvc.AcceptExtractors;
import play.api.mvc.Action;
import play.api.mvc.ActionBuilder;
import play.api.mvc.BaseController;
import play.api.mvc.BaseControllerHelpers;
import play.api.mvc.BodyParser;
import play.api.mvc.Call;
import play.api.mvc.Codec;
import play.api.mvc.ControllerComponents;
import play.api.mvc.ControllerHelpers;
import play.api.mvc.EssentialAction;
import play.api.mvc.Flash;
import play.api.mvc.Headers;
import play.api.mvc.InjectedController;
import play.api.mvc.PlayBodyParsers;
import play.api.mvc.Rendering;
import play.api.mvc.Request;
import play.api.mvc.RequestExtractors;
import play.api.mvc.RequestHeader;
import play.api.mvc.RequestImplicits;
import play.api.mvc.ResponseHeader;
import play.api.mvc.Result;
import play.api.mvc.Results;
import play.api.mvc.Session;
import play.api.mvc.Rendering.render.;
import play.api.mvc.Results.Status;
import scala.Function1;
import scala.MatchError;
import scala.NotImplementedError;
import scala.Option;
import scala.Some;
import scala.StringContext;
import scala.Tuple2;
import scala.collection.Seq;
import scala.collection.TraversableLike;
import scala.collection.immutable.Map;
import scala.concurrent.ExecutionContext;
import scala.concurrent.Future;
import scala.reflect.ScalaSignature;

@defining(if (powerApis) service.name + "PowerApi" else service.name) { serviceName =>
  /**
   * Abstract base class for implementing @{serviceName} and using as a play Router
   */
  public abstract class Abstract@{serviceName}Router extends PlayRouterUsingActions implements @{serviceName} {
    private final Function<ActorSystem, Function<Throwable, Status>> eHandler;
    private final ActorSystem system;
    private final ControllerComponents cc;
    @{
      val (streamingInputMethods: Seq[String], unaryInputMethods: Seq[String]) = service.methods.partition(_.inputStreaming) match {
        case (streaming, unary) => (streaming.map(_.grpcName), unary.map(_.grpcName))
      }
      "private final Seq[String] streamingInputMethods = Seq(" + streamingInputMethods.mkString("\"", "\", \"", "\"") + ");"
      "private final Seq[String] unaryInputMethods = Seq(" + unaryInputMethods.mkString("\"", "\", \"", "\"") + ");"
    }

    public Abstract@{serviceName}Router(Materializer mat, ActorSystem system, ControllerComponents cc) {
      this(mat, system, cc, GrpcExceptionHandler.defaultMapper());
    }

    public Abstract@{serviceName}Router(Materializer mat, ActorSystem system, ControllerComponents cc, Function<ActorSystem, Function<Throwable, Status>> eHandler) {
      super(mat, @{service.name}.name);
      this.eHandler = eHandler;
      this.system = system;
      this.cc = cc;
    }

    override protected Function<RequestHeader, EssentialAction> createHandler(String serviceName, Materializer mat) { //reqOuter =>
      override public EssentialAction apply(RequestHeader reqOuter) {
        //implicit val ec: ExecutionContext = mat.executionContext
        @{serviceName}Handler handler = @{serviceName}Handler.apply(this, serviceName, eHandler, mat, system);
        String[] pathSegments = reqOuter.split("/");
        if ((pathSegments.length == 2) && (pathSegments[0] == serviceName) {
          String method = pathSegments[1];
          if (streamingInputMethods.contains(method)) return createStreamingAction(handler, mat.executionContext);
          else if (unaryInputMethods.contains(method)) return createUnaryAction(handler, mat.executionContext);
          else throw new NotImplementedError("Not implemented: " + method);
        } else {
          throw new GrpcServiceException(GrpcStatus.INTERNAL.withDescription("Unexpected/handled path " + reqOuter.path));
        }
      }
    }

    EssentialAction createStreamingAction(handler: Function<HttpRequest, Future<HttpResponse>>, ec: ExecutionContext) {
      Action.async(streamBodyParser, new Function<HttpRequest, Future<HttpResponse>> {
        override Future<HttpResponse> public apply(HttpRequest req) {
          return handler(playToAkkaRequestStream(req)).map(resp => akkaToPlayResp(resp));
        }
      }
    }

/*
    def createUnaryAction(handler: HttpRequest => Future[HttpResponse])(implicit ec: ExecutionContext): EssentialAction = Action.async(parse.byteString) { req =>
      handler(playToAkkaRequest(req)).map(akkaToPlayResp(_))
    }

    def streamBodyParser(implicit ec: ExecutionContext): BodyParser[Source[ByteString, _]] = BodyParser("stream") { _ =>
      Accumulator
        .source[ByteString]
        .map(Right.apply)
    }

    def playToAkkaRequest(request: Request[ByteString]): HttpRequest = {
      val method = HttpMethods.getForKey(request.method.toUpperCase)
      val entity =
        HttpEntity.Chunked.fromData(Grpc.contentType, chunks = Source.single(request.body))
      HttpRequest(
        method   = HttpMethods.getForKey(request.method.toUpperCase).get,
        uri      = Uri(request.uri),
        headers  = playToAkkaHeaders(request),
        entity   = entity,
        protocol = HttpProtocols.getForKey(request.version.toUpperCase).get
      )
    }

    def playToAkkaRequestStream(request: Request[Source[ByteString, _]]): HttpRequest = {
      val method = HttpMethods.getForKey(request.method.toUpperCase)
      val entity =
        HttpEntity.Chunked.fromData(Grpc.contentType, chunks = request.body)
      HttpRequest(
        method   = HttpMethods.getForKey(request.method.toUpperCase).get,
        uri      = Uri(request.uri),
        headers  = playToAkkaHeaders(request),
        entity   = entity,
        protocol = HttpProtocols.getForKey(request.version.toUpperCase).get
      )
    }

    def playToAkkaHeaders(req: Request[_]): immutable.Seq[HttpHeader] = {
      immutable.Seq(req.headers.headers: _*).map { h =>
        HttpHeader.parse(h._1, h._2) match {
          case ParsingResult.Ok(header, errors) => header
          case ParsingResult.Error(error)       => throw new Exception("header parsing")
        }
      }
    }

    def akkaToPlayResp(akkaResp: HttpResponse): Result = {
      val playEntity = akkaResp.entity match {
        case HttpEntity.Chunked(ct, chunks) =>
          val playChunks: Source[HttpChunk, Any] = chunks.map {
            case HttpEntity.LastChunk(_, trailer) =>
              LastChunk(akkaToPlayHeaders(trailer))
            case HttpEntity.Chunk(data, ext) => Chunk(data)
          }
          Chunked(playChunks, Some(ct.toString()))
        case _ => ???
      }
      Result(akkaToPlayResponseHeaders(akkaResp), playEntity)
    }

    def akkaToPlayHeaders(headers: immutable.Seq[HttpHeader]): Headers = {
      Headers(headers.map(h => (h.name(), h.value())): _*)
    }

    def akkaToPlayResponseHeaders(resp: HttpResponse): ResponseHeader = {
      ResponseHeader(
        status  = OK,
        headers = akkaToPlayHeaders(resp.headers).toSimpleMap
      )
    }
    */
  }
}
