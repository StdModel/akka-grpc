@*
 * Copyright (C) 2018 Lightbend Inc. <https://www.lightbend.com>
 *@

@(service: akka.grpc.gen.scaladsl.Service, powerApis: Boolean)

@akka.grpc.gen.Constants.DoNotEditComment
package @service.packageName

import scala.concurrent.{ ExecutionContext, Future }

import akka.grpc.scaladsl.{ GrpcExceptionHandler, GrpcMarshalling, ScalapbProtobufSerializer, MetadataMap }
import akka.grpc.Codecs

import akka.http.scaladsl.model.{ HttpRequest, HttpResponse, StatusCodes }
import akka.http.scaladsl.model.Uri.Path
import akka.http.scaladsl.model.Uri.Path.Segment

import akka.stream.Materializer

import io.grpc.{Status => GrpcStatus}
import play.api.http.HttpChunk
import play.api.http.HttpChunk.{Chunk, LastChunk}
import play.api.http.HttpEntity.Chunked
import play.api.libs.streams.Accumulator
import play.api.mvc._

import akka.NotUsed
import akka.grpc.scaladsl
import akka.grpc.scaladsl.{GrpcMarshalling, MetadataMap}
import akka.grpc.{Codecs, Grpc, GrpcServiceException, ProtobufSerializer}
import akka.http.scaladsl.model.HttpHeader.ParsingResult
import akka.http.scaladsl.model.Uri.Path
import akka.http.scaladsl.model.Uri.Path.Segment
import akka.http.scaladsl.model._
import akka.stream.Materializer
import akka.stream.scaladsl.Source
import akka.util.ByteString
import play.api.http.HttpChunk
import play.api.http.HttpChunk.{Chunk, LastChunk}
import play.api.http.HttpEntity.Chunked
import play.api.libs.streams.Accumulator
import play.api.mvc._

import scala.collection.immutable
import scala.concurrent.ExecutionContext
import scala.util.control.NonFatal
import scala.util.{Failure, Success, Try}

@defining(service.name + (if (powerApis) "PowerApi" else "")) { serviceName =>
  class @{serviceName}Handler(cc: ControllerComponents) extends InjectedController with Results {
    setControllerComponents(cc)
    val notFound = Action(NotFound)

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `@{serviceName}Handler.partial` when combining
     * several services.
     */
    def apply(implementation: @serviceName)(implicit mat: Materializer): RequestHeader => EssentialAction =
      partial(implementation).orElse { case _ => notFound }

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `@{serviceName}Handler.partial` when combining
     * several services.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def apply(implementation: @serviceName, prefix: String)(implicit mat: Materializer): RequestHeader => EssentialAction =
      partial(implementation, prefix).orElse { case _ => notFound }

    /**
     * Creates a partial `HttpRequest` to `HttpResponse` handler that can be combined with handlers of other
     * services with `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` and then used in for example
     * `Http().bindAndHandleAsync`.
     *
     * Use `@{serviceName}Handler.apply` if the server is only handling one service.
     */
    def partial(implementation: @serviceName)(implicit mat: Materializer): PartialFunction[RequestHeader, EssentialAction] =
      partial(implementation, @{service.name}.name)

    /**
     * Creates a partial `HttpRequest` to `HttpResponse` handler that can be combined with handlers of other
     * services with `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` and then used in for example
     * `Http().bindAndHandleAsync`.
     *
     * Use `@{serviceName}Handler.apply` if the server is only handling one service.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def partial(implementation: @serviceName, prefix: String)(implicit mat: Materializer): PartialFunction[RequestHeader, EssentialAction] = {
      implicit val ec: ExecutionContext = mat.executionContext
      import @{service.name}.Serializers._

      def handle(request: RequestHeader, method: String): EssentialAction = method match {
        @for(method <- service.methods) {
        case "@method.grpcName" =>
            Action.async(@{if(method.inputStreaming) { "streamBodyParser" } else { "parse.byteString" }}) { request =>
              val akkaReq = @{if(method.inputStreaming) { "playToAkkaRequestStream(request)" } else { "playToAkkaRequest(request)" }}
              GrpcMarshalling.@{if(method.inputStreaming) { "unmarshalStream" } else { "unmarshal" }}(akkaReq)(@method.deserializer.name, mat).flatMap { in =>
                val res = implementation.@{method.name}(in @{if(powerApis) { ", MetadataMap(playToAkkaHeaders(request))" } else { "" }})
                @if(method.outputStreaming) { Future.successful(processGrpcResultStream(res, akkaReq)(@method.serializer.name, mat)) } else { res.map(processGrpcResult(_, akkaReq)(@method.serializer.name, mat)) }
              }
            }
        }
        case m => throw new NotImplementedError(s"Not implemented: $method")
      }

      Function.unlift(
        (req: RequestHeader) =>
          Path(req.path) match {
            case Path.Slash(Segment(`prefix`, Path.Slash(Segment(method, Path.Empty)))) â‡’
              Some {
                Try(handle(req, method)) match {
                  case Success(res) => res
                  case Failure(e: GrpcServiceException) => throw e
                  case Failure(NonFatal(t)) => throw new GrpcServiceException(GrpcStatus.UNIMPLEMENTED)
                }
              }
            case _ =>
              throw new GrpcServiceException(GrpcStatus.INTERNAL.withDescription(s"Unexpected/handled path ${req.path}"))
        }
      )
    }

    def streamBodyParser(implicit ec: ExecutionContext): BodyParser[Source[ByteString, _]] = BodyParser("stream") { _ =>
      Accumulator
        .source[ByteString]
        .map(Right.apply)
    }

    def playToAkkaRequest(request: Request[ByteString]): HttpRequest = {
      val method = HttpMethods.getForKey(request.method.toUpperCase)
      val entity =
        HttpEntity.Chunked.fromData(Grpc.contentType, chunks = Source.single(request.body))
      HttpRequest(
        method   = HttpMethods.getForKey(request.method.toUpperCase).get,
        uri      = Uri(request.uri),
        headers  = playToAkkaHeaders(request),
        entity   = entity,
        protocol = HttpProtocols.getForKey(request.version.toUpperCase).get
      )
    }

    def playToAkkaRequestStream(request: Request[Source[ByteString, _]]): HttpRequest = {
      val method = HttpMethods.getForKey(request.method.toUpperCase)
      val entity =
        HttpEntity.Chunked.fromData(Grpc.contentType, chunks = request.body)
      HttpRequest(
        method   = HttpMethods.getForKey(request.method.toUpperCase).get,
        uri      = Uri(request.uri),
        headers  = playToAkkaHeaders(request),
        entity   = entity,
        protocol = HttpProtocols.getForKey(request.version.toUpperCase).get
      )
    }

    def playToAkkaHeaders(req: Request[_]): immutable.Seq[HttpHeader] = {
      immutable.Seq(req.headers.headers: _*).map { h =>
        HttpHeader.parse(h._1, h._2) match {
          case ParsingResult.Ok(header, errors) => header
          case ParsingResult.Error(error)       => throw new Exception("header parsing")
        }
      }
    }

    def akkaToPlayHeaders(headers: immutable.Seq[HttpHeader]): Headers = {
      Headers(headers.map(h => (h.name(), h.value())): _*)
    }

    def akkaToPlayResponseHeaders(resp: HttpResponse): ResponseHeader = {
      ResponseHeader(
        status  = OK,
        headers = akkaToPlayHeaders(resp.headers).toSimpleMap
      )
    }

    def processGrpcResult[T](res: T, akkaReq: HttpRequest)(
        implicit ser: ProtobufSerializer[T],
        mat: Materializer
    ): Result = {
      val responseCodec = Codecs.negotiate(akkaReq)
      val akkaResp      = GrpcMarshalling.marshal(res /*, metadata */ )(ser, mat, responseCodec)
      val playEntity = akkaResp.entity match {
        case HttpEntity.Chunked(ct, chunks) =>
          val playChunks: Source[HttpChunk, Any] = chunks.map {
            case HttpEntity.LastChunk(_, trailer) =>
              LastChunk(akkaToPlayHeaders(trailer))
            case HttpEntity.Chunk(data, ext) => Chunk(data)
          }
          Chunked(playChunks, Some(ct.toString()))
        case _ => ???
      }
      Result(akkaToPlayResponseHeaders(akkaResp), playEntity)
    }

    def processGrpcResultStream[T](res: Source[T, NotUsed], akkaReq: HttpRequest)(
        implicit ser: ProtobufSerializer[T],
        mat: Materializer
    ): Result = {
      val responseCodec = Codecs.negotiate(akkaReq)
      val akkaResp      = GrpcMarshalling.marshalStream[T](res /*, metadata */ )(ser, mat, responseCodec)
      val playEntity = akkaResp.entity match {
        case HttpEntity.Chunked(ct, chunks) =>
          val playChunks: Source[HttpChunk, Any] = chunks.map {
            case HttpEntity.LastChunk(_, trailer) =>
              LastChunk(akkaToPlayHeaders(trailer))
            case HttpEntity.Chunk(data, ext) => Chunk(data)
          }
          Chunked(playChunks, Some(ct.toString()))
        case _ => ???
      }
      Result(akkaToPlayResponseHeaders(akkaResp), playEntity)
    }
  }
}
